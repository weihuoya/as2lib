interface org.as2lib.core.BasicInterface { 
      
     /** 
      * Returns a Class generated by the acutal instance. 
      *  
      * @throws org.as2lib.reflect.ReferenceNotFoundException if no reference from the class was found. 
      */ 
     public function getClass():org.as2lib.reflect.ClassInfo; 
}

interface org.as2lib.core.Cloneable {
      /** 
      * Returns a clone from actually used Object 
      *  
      * @throws org.as2lib.core.CloneNotSupportedException if the object was not possible to clone. 
      */ 
     public function clone(); 
}

interface org.as2lib.core.Overloading {
     /** 
      * Processes the overloading, finds a matching type within the TypeArray 
      * 
      * @param 
      * @param
      *
      * @throws  
      */ 
     public function overload(args:Array, overloadHandlers:TypedArray):Void; 
      
     /** 
      * Factory to create a new Overloadhandler simplyfies the access. 
      * 
      * @param 
      */ 
     public function createOverloadHandler(matches:TypedArray,forwardsTo:Function):OverloadHandler;
}
 
class org.as2lib.core.BasicClass implements org.as2lib.core.BasicInterface, org.as2lib.core.Cloneable, org.as2lib.core.Overloading {}
 
 
interface org.as2lib.reflect.ClassInfo { 
      
     /** 
      *  
      */ 
     public function getName(Void):String; 
     
     /** 
      *  
      */ 
     public function getConstructor(Void):Function; 
     
     /** 
      *  
      */ 
     public function newInstance(Void); 
      
     /** 
      * Returns a TypedArray from type String containing all Vars that an Instance of this class has. 
      */ 
     public function getVars(Void):TypedArray; 
     
     /** 
      * Returns a TypedArray from type MethodInfo containing all Methods that an Instance of this class has. 
      */ 
     public function getMethods(Void):TypedArray; 
      
     /** 
      * Returns a TypedArray from type String containing all Vars that the Class has. 
      */ 
     public function getStaticVars(Void):TypedArray; 
      
     /** 
      * Returns a TypedArray from type MethodInfo containing all Methods that the Class has. 
      */ 
     public function getStaticMethods(Void):TypedArray; 
 
} 
 
interface org.as2lib.core.OverloadHandler { 
     /** 
      * Returns true if the usedArguments 
      */ 
     public function matches (args:Array):Boolean;
      
     /** 
      * Executes  
      */ 
     public function execute (target, args:Array):Void; 
} 
 
class org.as2lib.core.SimpleOverloadHandler implements org.as2lib.core.OverloadHandler {} 
 
interface org.as2lib.reflect.MethodInfo { 
     public function getName():String; 
     public function getMethod():Function; 
     public function getDeclaringClass():ClassInfo; 
} 
 
class org.as2lib.reflect.SimpleMethodInfo implements org.as2lib.reflect.MethodInfo {} 

interface org.as2lib.core.Cloneable {
     public function clone();
}

class org.as2lib.exception extends Error implements BasicInterface {
	/**
	 * This function has a special implementation in this case.
	 * 1. It will return the same Information like #getStackTrace that will
	 *    get displayed on the Flash MX 2004 Output panel if the Exception
	 *    wont get chaught.
	 * 2. This methods is the only possibility to activate the Output Handler
	 *    org.as2lib.core.Out. This means if you call this function you will
	 *    see within your Outputreader that the Exceptions was thrown, even if
	 *    it was not.
	 */
     public function toString():String;

	/**
	 * 
	 */
     public function getStack():Stack;

	
     public function getStackTrace():String;
     public function initCause(e:Exception):Void;
     public function getCause():Exception;
     public function getMessage():String;
     public function getClass():ClassInfo;
}

class org.as2lib.core.TypedArray extends BasicClass {
     public static var CASEINSENSITIVE, DESCENDING, NUMERIC, RETURNINDEXDARRAY, UNIQUESORT;

     public function TypedArray(type:Function);
     public function concat(value0:TypedArray, value1:TypedArray, ..., valueN:TypedArray):TypedArray;
     public function getType():Function;
     public fucntion get(i:Number);
     public function set(i:Number, value):Void;
     public function join(separator:String):String;
     public function pop();
     public function push(value):Number;
     public function reverse():Void;
     public function shift();
     public function slice(start:Number, end:Number):TypedArray;
     public function sort();
     public function sortOn();
     public function splice(start:Number, deleteCount:Number, value0, value1...valueN):Void;
     public function toString():String;
     public function unshift(value0, value1...valueN):Number;
     public function getLength():Number;
     public function iterator():Iterator;
}


// Beifügung [zur Erinnerung]
class A extends BasicClass{
  public function getClass() {
    if(*wennichjetztnichtvoneinerExtendendenKlasseaufgerufenwerde*) {
      return *normal*
    } else {
      return *reflectionBasiert*
    }
  } 
}